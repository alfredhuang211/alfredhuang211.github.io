<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>使用 Serverless 进行 AI 预测推理 | 个人学习记录</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="">
    <meta name="generator" content="Hugo 0.104.3" />
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

<link href="https://alfredhuang211.github.io/css/kityminder.core.css" rel="stylesheet">
<link href="https://alfredhuang211.github.io/css/mindmap.css" rel="stylesheet">

<script src="https://alfredhuang211.github.io/js/kity.min.js"></script>
<script src="https://alfredhuang211.github.io/js/kityminder.core.min.js"></script>
<script src="https://alfredhuang211.github.io/js/jquery.slim.min.js"></script>
<script src="https://alfredhuang211.github.io/js/mindmap.js"></script>

    
    
      

    

    
    
    <meta property="og:title" content="使用 Serverless 进行 AI 预测推理" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://alfredhuang211.github.io/serverless/%E4%BD%BF%E7%94%A8serverless%E8%BF%9B%E8%A1%8Cai%E6%8E%A8%E7%90%86/" /><meta property="article:section" content="serverless" />
<meta property="article:published_time" content="2022-06-27T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-06-27T00:00:00+00:00" />

<meta itemprop="name" content="使用 Serverless 进行 AI 预测推理">
<meta itemprop="description" content=""><meta itemprop="datePublished" content="2022-06-27T00:00:00+00:00" />
<meta itemprop="dateModified" content="2022-06-27T00:00:00+00:00" />
<meta itemprop="wordCount" content="741">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="使用 Serverless 进行 AI 预测推理"/>
<meta name="twitter:description" content=""/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        个人学习记录
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/" title="Home page">
              Home
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/hugo" title="Hugo page">
              Hugo
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/web3" title="Web 3.0 page">
              Web 3.0
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/k8s" title="Kubernetes page">
              Kubernetes
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/serverless" title="Serverless page">
              Serverless
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/about" title="About page">
              About
            </a>
          </li>
          
        </ul>
      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        SERVERLESS
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">使用 Serverless 进行 AI 预测推理</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2022-06-27T00:00:00Z">June 27, 2022</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-solid serif f4 nested-links mid-gray pr4-l w-100-l"><h1 id="使用-serverless-进行-ai-预测推理">使用 Serverless 进行 AI 预测推理</h1>
<h2 id="概览">概览</h2>
<p>在 AI 项目中，通常大家关注的都是怎么进行训练、怎么调优模型、怎么来达到满意的识别率。但对于一个完整项目来说，通常是需求推动的项目，同时项目最终也要落到实际业务中来满足需求。对于 AI 项目来说，落地到实际项目中，就是将训练的模型，投入到生产环境中，使用生成环境的数据，根据模型进行推理预测，满足业务需求。</p>
<p>而常规的部署方案，通常都是将模型部署到一台独立设备上，对外以 API 接口的形式提供服务，业务模块或前端 APP 等所需预测推理能力的位置，通过调用 API，传递原始数据，由 AI 推理服务完成预测推理后，将结果返回。这个过程，通常称为 AI Serving。</p>
<p>对于最常用的 AI 训练和机器学习的工具 TensorFlow 来说，它本身也提供了 AI serving 工具 TensorFlow Serving。利用此工具，可以将训练好的模型简单保存为模型文件后，并通过脚本在 TensorFlow Serving 加载模型，输入待推理数据，得到推理结果。</p>
<p>而对于 AI 推理来说，其调用需求会随着业务的涨落而涨落，会出现白天高、夜间低的现象，而和 AI 训练时的较固定计算周期和运行时长而有所不同。同时，如果在推理时使用了 GPU 来加速，那一样存在着白天利用率高，夜间利用率低的现象，而又得为峰值时刻准备足够的 GPU 设备来避免业务拥塞或响应速度降低，很大程度上照成了资源浪费。</p>
<p>而利用 Serverless 的自动扩缩容技术，在实现 AI Serving 的云函数后，即可将其放心使用在业务中。在高业务请求到来时，云函数的执行实例自动扩容，满足业务需求；而在请求低谷到来时，或者无请求到来时，云函数自动缩容甚至完全停止，节省资源使用。同时，云函数按执行时间进行计费的方式，也可以更进一步的节约费用使用，避免为长时间空闲的 GPU 设备付费。</p>
<p>接下来，我们就演示下如何使用腾讯云的 SCF 无服务器云函数来实现 AI Serving 能力。目前，SCF 云函数产品，已经在python 2.7 环境内内置了 TensorFlow Serving 及相关的 Python 库，可支持直接调用 Serving 组件。同时 SCF 云函数也已经灰度开放了 GPU 支持，可以使用 GPU 来进一步加快 AI 推理速度。</p>
<h2 id="模型准备">模型准备</h2>
<p>在这里我们使用 TensorFlow 中的 MNIST 实验作为案例来进行下面的介绍。MNIST 是一个包含了 6 万训练图片和 1 万测试图片的手写数字图片集合，图片为 28x28-pixel 大小的黑白图片。此训练集通常用来训练对数字的识别能力。</p>
<p>关于如何编写代码，使用 MNIST 训练集完成模型训练，可以见 <a href="https://www.tensorflow.org/tutorials/layers?hl=zh-cn">TF层指南：建立卷积神经网络</a>，这篇文章详细介绍了如何通过使用 Tensorflow layer 构建卷积神经网络，并设置如何进行训练和评估。</p>
<p>而在进行训练和评估后，就可以进行模型的导出了。TensorFlow 的模型文件包含了深度学习模型的 Graph 和参数，也就是 checkpoint 文件。在导出模型文件后，我们可以加载模型文件继续训练或者对外提供推理服务。</p>
<p>这里我们可以通过 SavedModelBuilder 模块来进行模型到处保存，更具体的文档和操作方法可见 <a href="https://www.tensorflow.org/serving/serving_basic?hl=zh-cn#train_and_export_tensorflow_model">训练和导出 TF 模型</a>。</p>
<p>导出后的文件，为 saved_model.pb 文件， variables 文件夹及包含的若干variables文件，分别是模型的图文件和参数文件。后续在提供推理能力时，就是使用这些图及变量文件，加载到 TF Serving 内。</p>
<p>为了便于后续的操作，我们在这里也直接提供我们导出的模型文件供后续操作，可以点击这里的<a href="https://main.qcloudimg.com/raw/c184a8b6e802192e4ff71ecb4cb07ec8.zip">导出模型文件</a>来下载。</p>
<h2 id="测试文件准备">测试文件准备</h2>
<p>测试文件我们可以从 MNIST 的测试集中随意抽取若干，用于验证我们最终推理 API 的工作状态。同样，我们也在这里准备了若干图片用于最终验证，可以点击这里的<a href="https://main.qcloudimg.com/raw/3353ca26b71061c7b3f3c57bc8039832.zip">测试图片文件</a>来下载。或者记录以下连接，用于直接测试在线图片的推理情况。</p>
<pre tabindex="0"><code>https://main.qcloudimg.com/raw/84783c178cdc6d6b2302bc1b4749b91b.bmp
https://main.qcloudimg.com/raw/0f4630a815c44107a79a224d3263da2c.bmp
https://main.qcloudimg.com/raw/360a7cdd638d22d4145c94e67b3c059f.bmp
https://main.qcloudimg.com/raw/90067917b01d4b4d31f207ac78e70416.bmp
https://main.qcloudimg.com/raw/7828379e768aa5c8a6d09a3d58f64921.bmp
https://main.qcloudimg.com/raw/79e0c07766c739c880dfed8d0433ff83.bmp
https://main.qcloudimg.com/raw/b5f1c6f4ba08c3376c333c5a62f0c1dd.bmp
https://main.qcloudimg.com/raw/40adedc18205428276c3753bac51e740.bmp
https://main.qcloudimg.com/raw/4c750171b4b31772f0b923beef92c9f3.bmp
https://main.qcloudimg.com/raw/8504482825667f97b21209b9570249e6.bmp
https://main.qcloudimg.com/raw/5f22f6f83d26a3f267c823cd5437bdfc.bmp
https://main.qcloudimg.com/raw/fb1f59a3fdbcad0a140045508f28f688.bmp
</code></pre><h2 id="函数创建及测试">函数创建及测试</h2>
<p>我们使用如下示例来创建函数程序包。</p>
<h3 id="准备函数文件">准备函数文件</h3>
<p>创建目录 mnist_demo，并在根目录下创建文件 mnist.py，文件内容如下。</p>
<pre tabindex="0"><code>#!/usr/bin/env python2.7

import os
import sys
import base64
import urllib
import tensorflow as tf
import numpy as np
import utils
import json

os.environ[&#39;TF_CPP_MIN_LOG_LEVEL&#39;] = &#39;2&#39;

# Load model
cur_dir = os.getcwd()
model_dir = cur_dir+&#34;/export/4&#34;
sess = tf.Session(graph=tf.Graph())
meta_graph_def = tf.saved_model.loader.load(sess, [tf.saved_model.tag_constants.SERVING], model_dir)
x = sess.graph.get_tensor_by_name(&#39;x:0&#39;)
y = sess.graph.get_tensor_by_name(&#39;y:0&#39;)

def run(event):
    local_path = &#34;&#34;
    if event[&#39;image_base64&#39;] != &#34;&#34;:
        data=base64.b64decode(event[&#39;image_base64&#39;])
        local_path = &#39;/tmp/test_image.xxx&#39;
        file=open(local_path,&#39;wb&#39;)
        file.write(data)
        file.close()
    elif event[&#39;image_url&#39;] != &#34;&#34;:
        img_url = event[&#39;image_url&#39;]
        filename = urllib.unquote(img_url).decode(&#39;utf8&#39;).split(&#39;/&#39;)[-1]
        local_path = os.path.join(&#39;/tmp/&#39;, filename)
        if not utils.download_image(event[&#39;image_url&#39;], local_path):
            return False, -1
    else:
        print(&#39;Please specify a image.&#39;)

    try:
        x_ = utils.get_image_array(local_path)
        predict = tf.argmax(y, 1)
        res = sess.run(predict, feed_dict={x: x_})[0] 
        return True, sess.run(predict, feed_dict={x: x_})[0]
    except Exception as e:
        print(e)
        return False, -1

def demo(event, context):
    res, num = run(event)
    print num
    return num
        
def apigw_interface(event, context):
    if &#39;requestContext&#39; not in event.keys():
        return {&#34;errMsg&#34;:&#34;request not from api gw&#34;}
    body_str = event[&#39;body&#39;]
    body_info = json.loads(body_str)
    res, num = run(body_info)
    return {&#34;result&#34;:num}
</code></pre><p>从代码中我们可以看到，函数在初始化时就将目录 export 下的文件作为模型加载到了 TensorFlow 中。在实际的事件处理中，既可以从事件中抽取 base64 编码后的图片，也可以识别 url 参数，并均把图片保存至本地 /tmp 目录下。然后在使用 util 工具，对图片进行规整处理后，将处理后的数据送入 TensorFlow，获得推理结果并返回。</p>
<p>在根目录下同时创建 util.py，代码内容如下。此模块提供了图片下载、图片处理等辅助能力。</p>
<pre tabindex="0"><code>#!/usr/bin/env python2.7

import urllib2
import numpy as np
from PIL import Image

def download_image(img_url, local_file):
    ret = True
    try: 
      f = urllib2.urlopen(img_url)
      data = f.read()
      with open(local_file, &#34;wb&#34;) as img:
          img.write(data)
    except Exception as e:
        print(e)
        ret = False
    return ret

def get_image_array(img_path):
    x_s = 28
    y_s = 28
    n0 = 0
    n255 = 0
    threshold = 100
    im = None
    im = Image.open(img_path)

    img = np.array(im.resize((x_s, y_s), Image.ANTIALIAS).convert(&#39;L&#39;))

    for x in range(x_s):
      for y in range(y_s):
        if img[x][y] &gt; threshold:
          n255 = n255 + 1
        else:
          n0 = n0 + 1

    if(n255 &gt; n0) :
      for x in range(x_s):
        for y in range(y_s):
          img[x][y] = 255 - img[x][y]
          if(img[x][y] &lt; threshold) :
            img[x][y] = 0

    arr = img.reshape((1, 784))
    arr = arr.astype(np.float32)
    arr = np.multiply(arr, 1.0 / 255.0)
    return arr
</code></pre><p>同时由于 util.py 中使用了 PIL 库，需要在代码根目录下提供 PIL 库，可以使用此 <a href="https://main.qcloudimg.com/raw/7e394fa1410e615da121dd5748d8724d.zip">PIL库文件</a> 来下载库并解压后放置在代码根目录。</p>
<h3 id="准备函数部署包">准备函数部署包</h3>
<p>最终，我们得到的代码目录结构为如下结构，其中PIL文件夹下由于文件过多就不进行展开了。</p>
<pre tabindex="0"><code>mnist_demo
|
|-- mnist.py
|-- utils.py
| export
    | 4
        |-- saved_model.pb
        | variables
            |-- variables.data-00000-of-00001
            |-- variables.index
| PIL
    |-- ...
</code></pre><p>在 mnist_demo 这个目录下，我们选择所有文件然后打包为 zip 包。注意，这些文件需要在 zip 包的根目录下，而不是 mnist_demo 文件夹在zip包的根目录。</p>
<p>最终我们得到了一个可以上传到云函数的 zip 包。如果对于前面的操作都不想进行，也可以直接在<a href="https://main.qcloudimg.com/raw/4d3540e468b3caa757429f85cd9c0915.zip">这里</a>下载已经打好的包即可。</p>
<h3 id="创建函数">创建函数</h3>
<p>由于创建的函数部署包稍大，所以我们需要通过对象存储来上传代码包。</p>
<p>我们可以在腾讯云对象存储 COS 中先创建一个 bucket，例如在广州区创建名为 code 的 bucket，并将上一步获取的代码包上传 bucket，作为我们后续创建函数的代码来源。</p>
<p>进入腾讯云无服务器云函数 SCF 的<a href="https://console.cloud.tencent.com/scf/list">控制台</a>，选择广州区以后，点击新建函数，为函数起一个比较容易记住的名字，例如 testai，选择运行环境为 Python 2.7，然后下一步到代码配置页面。</p>
<p>在代码配置页面，选择代码输入种类为 <code>通过 COS 上传 zip 包</code>，选择刚刚创建的bucket为 cos，并填写对象文件为 <code>/mnist_demo.zip</code>。</p>
<p>同时，函数执行方法需要确定为 <strong>mnist.apigw_interface</strong>，对应代码包中的 mnist 文件和 apigw_interface 函数。</p>
<h3 id="测试函数">测试函数</h3>
<p>点击函数界面右上角的测试按钮，并使用如下测试模版来测试函数。</p>
<pre tabindex="0"><code>{
  &#34;requestContext&#34;: {
    &#34;serviceName&#34;: &#34;testsvc&#34;,
    &#34;path&#34;: &#34;/test/{path}&#34;,
    &#34;httpMethod&#34;: &#34;POST&#34;,
    &#34;requestId&#34;: &#34;c6af9ac6-7b61-11e6-9a41-93e8deadbeef&#34;,
    &#34;identity&#34;: {
      &#34;secretId&#34;: &#34;abdcdxxxxxxxsdfs&#34;
    },
    &#34;sourceIp&#34;: &#34;10.0.2.14&#34;,
    &#34;stage&#34;: &#34;prod&#34;
  },
  &#34;headers&#34;: {
    &#34;Accept-Language&#34;: &#34;en-US,en,cn&#34;,
    &#34;Accept&#34;: &#34;text/html,application/xml,application/json&#34;,
    &#34;Host&#34;: &#34;service-3ei3tii4-251000691.ap-guangzhou.apigateway.myqloud.com&#34;,
    &#34;User-Agent&#34;: &#34;User Agent String&#34;
  },
  &#34;body&#34;: &#34;{\&#34;image_base64\&#34;: \&#34;\&#34;, \&#34;image_url\&#34;: \&#34;https://main.qcloudimg.com/raw/84783c178cdc6d6b2302bc1b4749b91b.bmp\&#34;}&#34;,
  &#34;pathParameters&#34;: {
    &#34;path&#34;: &#34;value&#34;
  },
  &#34;queryStringParameters&#34;: {
    &#34;foo&#34;: &#34;bar&#34;
  },
  &#34;headerParameters&#34;:{
    &#34;Refer&#34;: &#34;10.0.2.14&#34;
  },
  &#34;stageVariables&#34;: {
    &#34;stage&#34;: &#34;test&#34;
  },
  &#34;path&#34;: &#34;/test/value?foo=bar&#34;,
  &#34;httpMethod&#34;: &#34;POST&#34;
}
</code></pre><p>这里可以看到，我们主要使用了body字段，并在body字段内填写的数据结构为：</p>
<pre tabindex="0"><code>{
  &#34;image_base64&#34;: &#34;&#34;,
  &#34;image_url&#34;: &#34;https://main.qcloudimg.com/raw/84783c178cdc6d6b2302bc1b4749b91b.bmp&#34;
}
</code></pre><p>这个数据结构也是我们创建的函数所能接受和处理的结构，如果有 base64 编码的图片文件内容，则使用编码的内容，或者使用url传入的图片地址，将图片下载到本地后交由 TensorFlow 进行预测推理。在这里测试时，我们可以用上我们在一开始准备的图片地址，而在实际推理时，可以替换成其他可访问的图片地址。</p>
<p>点击测试运行后，如果使用的是上面的地址，使用的是第一副图片，那么函数的返回内容将是 <code>{&quot;result&quot;: 0}</code>，标识其推理出来的图片内是数值 0。</p>
<h2 id="使用-api-网关进行-api-封装">使用 API 网关进行 API 封装</h2>
<p>接下来我们通过 API 网关服务，来创建一个 API 对刚刚创建的推理函数进行封装，并对外提供 API 服务。</p>
<h3 id="创建-api-服务及-api">创建 API 服务及 API</h3>
<p>首先在 API 网关的控制台，在广州区创建一个 API 服务。服务名可以起一个容易记住的名字，例如 testai。</p>
<p>接着进入API 管理，创建 API。同样可以起一个容易记住的名字，例如 ai。请求路径可以写为 /ai，请求方法为 POST。为了方便调试，我们这里可以勾选上免鉴权。</p>
<p>接着下一步，后端类型选择为 cloud function，并选择我们在前面创建的函数 testai。</p>
<p>最后一步填入响应内容为 JSON，描述正确示例为 <code>{&quot;result&quot;:0}</code>，错误示例为 <code>{&quot;errMsg&quot;:&quot;error info&quot;}</code> 即可。</p>
<h3 id="调试-api">调试 API</h3>
<p>点击 API 查看界面的 API 调试，进入调试页面。确定 Content-Type 为 application/json，输入框内填入以下内容后点击发送请求。</p>
<pre tabindex="0"><code>{
  &#34;image_base64&#34;: &#34;&#34;,
  &#34;image_url&#34;: &#34;https://main.qcloudimg.com/raw/84783c178cdc6d6b2302bc1b4749b91b.bmp&#34;
}
</code></pre><p>确认响应的 body 为 {&ldquo;result&rdquo;: 0}，符合预期。同理，这里的 url 地址同样可以更改，并且响应内容随图片的不同而不同。</p>
<h3 id="api-发布及外网测试">API 发布及外网测试</h3>
<p>在 API 调试成功后，我们可以在服务列表页面，将我们刚刚创建的 testai 服务发布到 <code>发布环境</code>。</p>
<p>然后根据 testai 的服务域名，我们可以得到刚才的 API 的完整路径为：<code>http://service-kzeyrb6x-1253970226.ap-beijing.apigateway.myqcloud.com/release/ai</code>。我们可以使用 http request 的发起工具，例如 Postman，或 restclient 等，向此 API 地址发起 POST请求，POST内容可以为如下内容。</p>
<pre tabindex="0"><code>{
  &#34;image_base64&#34;: &#34;&#34;,
  &#34;image_url&#34;: &#34;https://main.qcloudimg.com/raw/84783c178cdc6d6b2302bc1b4749b91b.bmp&#34;
}
</code></pre><p>或</p>
<pre tabindex="0"><code>{
  &#34;image_base64&#34;: &#34;Qk1mCQAAAAAAADYAAAAoAAAAHAAAABwAAAABABgAAAAAADAJAAAAAAAAAAAAAAAAAAAAAAAA////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////AAAA////////////////////////////////////////////////////////////////////////////////////////////////////////////AAAAAAAA////////////////////////////////////////////////////////////////////////////////////////////////////////AAAAAAAA////////////////////////////////////////////////////////////////////////////////////////////////////////AAAAAAAA////////////////////////////////////////////////////////////////////////////////////////////////////////AAAAAAAAAAAA////////////////////////////////////////////////////////////////////////////////////////////////////////AAAAAAAA////////////////////////////////////////////////////////////////////////////////////////////////////////AAAAAAAA////////////////////////////////////////////////////////////////////////////////////////////////////////AAAAAAAAAAAA////////////////////////////////////////////////////////////////////////////////////////////////////////AAAAAAAA////////////////////////////////////////////////////////////////////////////////////////////////////////AAAAAAAA////////////////////////////////////////////////////////////////////////////////////////////////////////AAAAAAAA////////////////////////////////////////////////////////////////////////////////////////////////////////AAAAAAAAAAAA////////////////////////////////////////////////////////////////////////////////////////////////////////AAAAAAAA////////////////////////////////////////////////////////////////////////////////////////////////////////AAAAAAAA////////////////////////////////////////////////////////////////////////////////////////////////////////AAAAAAAAAAAA////////////////////////////////////////////////////////////////////////////////////////////////////////AAAAAAAA////////////////////////////////////////////////////////////////////////////////////////////////////////AAAAAAAA////////////////////////////////////////////////////////////////////////////////////////////////////////AAAAAAAAAAAA////////////////////////////////////////////////////////////////////////////////////////////////////////AAAAAAAA////////////////////////////////////////////////////////////////////////////////////////////////////////AAAAAAAA////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////&#34;,
  &#34;image_url&#34;: &#34;&#34;
}
</code></pre><p>这两个不同的数据结构，分别测试了使用 base64 编码的图片内容，或者使用图片 url 地址传递图片内容的方式。同时可以根据自身需求，修改数据结构内的 image_base64 或 image_url 内容，查看测试结果。</p>
<h2 id="总结">总结</h2>
<p>我们在这里，通过一段实际的代码，及 TensorFlow 训练出来的模型，实现了利用 Serverless 架构进行 AI 推理，并通过 API 网关的封装，使得 AI 能力能够以 API 的形式对外暴露。可以看到，在获取到 TensorFlow 训练出的模型后，可以通过简单的函数包装，立即开始对外提供预测推理服务，而无需准备服务器，配置 web server 等繁琐配置准备操作。同时，在训练模型调优后，可以通过简单的升级函数，或发布新的函数版本，完成模型更新，而对用户提供无感知的升级。</p>
<p>Serverless 以按需调用，按运行计费的方式，使得 AI 推理服务的提供成本可以大幅降低，供应速度进一步提升，可以使得更多的 AI 能力能尽快服务于客户。</p>
<p>同时，目前上面提供的 AI 推理，由于比较简单，并无需使用 GPU。而在模型较复杂，计算量较大的情况下，使用 GPU 将能进一步加速推理速度。GPU 的使用，可以为 AI 推理的速度带来数量级的加速，将有些需要使用 CPU 秒级的推理，降低到使用 GPU 的10ms级。目前腾讯云云函数已经灰度开放了 GPU 支持能力，欢迎大家递交工单或提供联系方式，申请试用。</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://alfredhuang211.github.io/" >
    &copy;  个人学习记录 2022 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
